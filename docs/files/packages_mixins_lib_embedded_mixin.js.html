<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/mixins/lib/embedded_mixin.js - Extensions for Ember Data</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Extensions for Ember Data"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0-beta.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/DS.EmbeddedAdapter.html">DS.EmbeddedAdapter</a></li>
            
                <li><a href="../classes/DS.EmbeddedInModel.html">DS.EmbeddedInModel</a></li>
            
                <li><a href="../classes/DS.EmbeddedInModelMixin.html">DS.EmbeddedInModelMixin</a></li>
            
                <li><a href="../classes/DS.EmbeddedMixin.html">DS.EmbeddedMixin</a></li>
            
                <li><a href="../classes/DS.EmbeddedSerializer.html">DS.EmbeddedSerializer</a></li>
            
                <li><a href="../classes/DS.ModelWithEmbedded.html">DS.ModelWithEmbedded</a></li>
            
                <li><a href="../classes/DS.ModelWithEmbeddedMixin.html">DS.ModelWithEmbeddedMixin</a></li>
            
                <li><a href="../classes/DS.UnderscoredAdapterMixin.html">DS.UnderscoredAdapterMixin</a></li>
            
                <li><a href="../classes/DS.UnderscoredSerializer.html">DS.UnderscoredSerializer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/embedded-adapter.html">embedded-adapter</a></li>
            
                <li><a href="../modules/ember-data.html">ember-data</a></li>
            
                <li><a href="../modules/mixins.html">mixins</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: packages/mixins/lib/embedded_mixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(Ember, DS) {

var get = Ember.get;
var forEach = Ember.EnumerableUtils.forEach;

/**
  @module ember-data
  @submodule mixins
**/

/**
  DS.EmbeddedMixin supports serializing embedded records.

  To set up embedded records, include the mixin into a serializer then
  define embedded (model) relationships.

  Below is an example of a per type serializer (post type).

  &#x60;&#x60;&#x60;js
  App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedMixin, {
    attrs: {
      author: {embedded: &#x27;always&#x27;},
      comments: {embedded: &#x27;always&#x27;}
    }
  })
  &#x60;&#x60;&#x60;

  Currently only &#x60;{embedded: &#x27;always&#x27;}&#x60; records are supported.

  @class EmbeddedMixin
  @namespace DS
*/
DS.EmbeddedMixin = Ember.Mixin.create({

  /**
    Serialize &#x60;belongsTo&#x60; relationship when it is configured as an embedded object.

    This example of an author model belongs to a post model:

    &#x60;&#x60;&#x60;js
    Post = DS.Model.extend({
      title:    DS.attr(&#x27;string&#x27;),
      body:     DS.attr(&#x27;string&#x27;),
      author:   DS.belongsTo(&#x27;author&#x27;)
    });

    Author = DS.Model.extend({
      name:     DS.attr(&#x27;string&#x27;),
      post:     DS.belongsTo(&#x27;post&#x27;)
    });
    &#x60;&#x60;&#x60;

    Use a custom (type) serializer for the post model to configure embedded author

    &#x60;&#x60;&#x60;js
    App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedMixin, {
      attrs: {
        author: {embedded: &#x27;always&#x27;}
      }
    })
    &#x60;&#x60;&#x60;

    A payload with an attribute configured for embedded records can serialize
    the records together under the root attribute&#x27;s payload:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;author&quot;: {
          &quot;id&quot;: &quot;2&quot;
          &quot;name&quot;: &quot;dhh&quot;
        }
      }
    }
    &#x60;&#x60;&#x60;

    @method serializeBelongsTo
    @param {DS.Model} record
    @param {Object} json
    @param relationship
  */
  serializeBelongsTo: function(record, json, relationship) {
    var attr = relationship.key, config = this.get(&#x27;attrs&#x27;);

    if (!config || !isEmbedded(config[attr])) {
      this._super(record, json, relationship);
      return;
    }
    var key = this.keyForAttribute(attr);
    var embeddedRecord = record.get(attr);
    if (!embeddedRecord) {
      json[key] = null;
    } else {
      json[key] = embeddedRecord.serialize();
      var id = embeddedRecord.get(&#x27;id&#x27;);
      if (id) {
        json[key].id = id;
      }
      var parentKey = this.keyForAttribute(relationship.parentType.typeKey);
      if (parentKey) {
        removeId(parentKey, json[key]);
      }
      delete json[key][parentKey];
    }
  },

  /**
    Serialize &#x60;hasMany&#x60; relationship when it is configured as embedded objects.

    This example of a post model has many comments:

    &#x60;&#x60;&#x60;js
    Post = DS.Model.extend({
      title:    DS.attr(&#x27;string&#x27;),
      body:     DS.attr(&#x27;string&#x27;),
      comments: DS.hasMany(&#x27;comment&#x27;)
    });

    Comment = DS.Model.extend({
      body:     DS.attr(&#x27;string&#x27;),
      post:     DS.belongsTo(&#x27;post&#x27;)
    });
    &#x60;&#x60;&#x60;

    Use a custom (type) serializer for the post model to configure embedded comments

    &#x60;&#x60;&#x60;js
    App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedMixin, {
      attrs: {
        comments: {embedded: &#x27;always&#x27;}
      }
    })
    &#x60;&#x60;&#x60;

    A payload with an attribute configured for embedded records can serialize
    the records together under the root attribute&#x27;s payload:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;body&quot;: &quot;I want this for my ORM, I want that for my template language...&quot;
        &quot;comments&quot;: [{
          &quot;id&quot;: &quot;1&quot;,
          &quot;body&quot;: &quot;Rails is unagi&quot;
        }, {
          &quot;id&quot;: &quot;2&quot;,
          &quot;body&quot;: &quot;Omakase O_o&quot;
        }]
      }
    }
    &#x60;&#x60;&#x60;

    To embed the ids for a related object (using a hasMany relationship):
    &#x60;&#x60;&#x60;js
    App.PostSerializer = DS.RESTSerializer.extend(DS.EmbeddedMixin, {
      attrs: {
        comments: {embedded: &#x27;ids&#x27;}
      }
    })
    &#x60;&#x60;&#x60;

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;body&quot;: &quot;I want this for my ORM, I want that for my template language...&quot;
        &quot;comments&quot;: [&quot;1&quot;, &quot;2&quot;]
      }
    }
    &#x60;&#x60;&#x60;

    @method serializeHasMany
    @param {DS.Model} record
    @param {Object} json
    @param relationship
  */
  serializeHasMany: function(record, json, relationship) {
    var attr = relationship.key, config = this.get(&#x27;attrs&#x27;), key;

    if (!config || (!isEmbedded(config[attr]) &amp;&amp; !hasEmbeddedIds(config[attr]))) {
      this._super(record, json, relationship);
      return;
    }
    if (hasEmbeddedIds(config[attr])) {
      key = this.keyForRelationship(attr, relationship.kind);
      json[key] = get(record, attr).mapBy(get(this, &#x27;primaryKey&#x27;));
    } else {
      key = this.keyForAttribute(attr);
      json[key] = get(record, attr).map(function(relation) {
        var data = relation.serialize(),
            primaryKey = get(this, &#x27;primaryKey&#x27;);

        data[primaryKey] = get(relation, primaryKey);
        if (data.id === null) {
          delete data.id;
        }
        return data;
      }, this);
    }
  },

  /**
    Extract an embedded object from the payload for a single object
    and add the object in the compound document (side-loaded) format instead.

    A payload with an attribute configured for embedded records needs to be extracted:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: 1
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;author&quot;: {
          &quot;id&quot;: 2
          &quot;name&quot;: &quot;dhh&quot;
        }
        &quot;comments&quot;: []
      }
    }
    &#x60;&#x60;&#x60;

    Ember Data is expecting a payload with a compound document (side-loaded) like:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;author&quot;: &quot;2&quot;
        &quot;comments&quot;: []
      },
      &quot;authors&quot;: [{
        &quot;id&quot;: &quot;2&quot;
        &quot;post&quot;: &quot;1&quot;
        &quot;name&quot;: &quot;dhh&quot;
      }]
      &quot;comments&quot;: []
    }
    &#x60;&#x60;&#x60;

    The payload&#x27;s &#x60;author&#x60; attribute represents an object with a &#x60;belongsTo&#x60; relationship.
    The &#x60;post&#x60; attribute under &#x60;author&#x60; is the foreign key with the id for the post

    @method extractSingle
    @param {DS.Store} store
    @param {subclass of DS.Model} primaryType
    @param {Object} payload
    @param {String} recordId
    @param {&#x27;find&#x27;|&#x27;createRecord&#x27;|&#x27;updateRecord&#x27;|&#x27;deleteRecord&#x27;} requestType
    @return Object the primary response to the original request
  */
  extractSingle: function(store, primaryType, payload, recordId, requestType) {
    var root = this.keyForAttribute(primaryType.typeKey),
        partial = payload[root];

    updatePayloadWithEmbedded.call(this, store, primaryType, payload, partial);

    return this._super(store, primaryType, payload, recordId, requestType);
  },

  /**
    Extract embedded objects in an array when an attr is configured for embedded,
    and add them as side-loaded objects instead.

    A payload with an attr configured for embedded records needs to be extracted:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;comments&quot;: [{
          &quot;id&quot;: &quot;1&quot;,
          &quot;body&quot;: &quot;Rails is unagi&quot;
        }, {
          &quot;id&quot;: &quot;2&quot;,
          &quot;body&quot;: &quot;Omakase O_o&quot;
        }]
      }
    }
    &#x60;&#x60;&#x60;

    Ember Data is expecting a payload with compound document (side-loaded) like:

    &#x60;&#x60;&#x60;js
    {
      &quot;post&quot;: {
        &quot;id&quot;: &quot;1&quot;
        &quot;title&quot;: &quot;Rails is omakase&quot;,
        &quot;comments&quot;: [&quot;1&quot;, &quot;2&quot;]
      },
      &quot;comments&quot;: [{
        &quot;id&quot;: &quot;1&quot;,
        &quot;body&quot;: &quot;Rails is unagi&quot;
      }, {
        &quot;id&quot;: &quot;2&quot;,
        &quot;body&quot;: &quot;Omakase O_o&quot;
      }]
    }
    &#x60;&#x60;&#x60;

    The payload&#x27;s &#x60;comments&#x60; attribute represents records in a &#x60;hasMany&#x60; relationship

    @method extractArray
    @param {DS.Store} store
    @param {subclass of DS.Model} primaryType
    @param {Object} payload
    @return {Array&lt;Object&gt;} The primary array that was returned in response
      to the original query.
  */
  extractArray: function(store, primaryType, payload) {
    var root = this.keyForAttribute(primaryType.typeKey),
        partials = payload[Ember.String.pluralize(root)];

    forEach(partials, function(partial) {
      updatePayloadWithEmbedded.call(this, store, primaryType, payload, partial);
    }, this);

    return this._super(store, primaryType, payload);
  }
});

// checks config for embedded flag
function isEmbedded(config) {
  return config &amp;&amp; (config.embedded === &#x27;always&#x27; || config.embedded === &#x27;load&#x27;);
}

// checks config for included ids flag
function hasEmbeddedIds(config) {
  return config &amp;&amp; (config.embedded === &#x27;ids&#x27;);
}

// used to remove id (foreign key) when embedding
function removeId(key, json) {
  var idKey = key + &#x27;_id&#x27;;
  if (json.hasOwnProperty(idKey)) {
    delete json[idKey];
  }
}

// chooses a relationship kind to branch which function is used to update payload
// does not change payload if attr is not embedded
function updatePayloadWithEmbedded(store, type, payload, partial) {
  var attrs = get(this, &#x27;attrs&#x27;);

  if (!attrs) {
    return;
  }
  type.eachRelationship(function(key, relationship) {
    var config = attrs[key];

    if (isEmbedded(config)) {
      if (relationship.kind === &quot;hasMany&quot;) {
        updatePayloadWithEmbeddedHasMany.call(this, store, key, relationship, payload, partial);
      }
      if (relationship.kind === &quot;belongsTo&quot;) {
        updatePayloadWithEmbeddedBelongsTo.call(this, store, key, relationship, payload, partial);
      }
    }
  }, this);
}

// handles embedding for &#x60;hasMany&#x60; relationship
function updatePayloadWithEmbeddedHasMany(store, primaryType, relationship, payload, partial) {
  var serializer = store.serializerFor(relationship.type.typeKey);
  var primaryKey = get(this, &#x27;primaryKey&#x27;);
  var attr = relationship.type.typeKey;
  // underscore forces the embedded records to be side loaded.
  // it is needed when main type === relationship.type
  var embeddedTypeKey = &#x27;_&#x27; + Ember.String.pluralize(attr);
  var expandedKey = this.keyForRelationship(primaryType, relationship.kind);
  var attribute  = this.keyForAttribute(primaryType);
  var ids = [];

  if (!partial[attribute]) {
    return;
  }

  payload[embeddedTypeKey] = payload[embeddedTypeKey] || [];

  forEach(partial[attribute], function(data) {
    var embeddedType = store.modelFor(attr);
    updatePayloadWithEmbedded.call(serializer, store, embeddedType, payload, data);
    ids.push(data[primaryKey]);
    payload[embeddedTypeKey].push(data);
  });

  partial[expandedKey] = ids;
  delete partial[attribute];
}

// handles embedding for &#x60;belongsTo&#x60; relationship
function updatePayloadWithEmbeddedBelongsTo(store, primaryType, relationship, payload, partial) {
  var attrs = this.get(&#x27;attrs&#x27;);

  if (!attrs ||
    !(isEmbedded(attrs[Ember.String.camelize(primaryType)]) || isEmbedded(attrs[primaryType]))) {
    return;
  }
  var attr = relationship.type.typeKey;
  var serializer = store.serializerFor(relationship.type.typeKey);
  var primaryKey = get(serializer, &#x27;primaryKey&#x27;);
  var embeddedTypeKey = Ember.String.pluralize(attr);
  var expandedKey = serializer.keyForRelationship(primaryType, relationship.kind);
  var attribute = serializer.keyForAttribute(primaryType);

  if (!partial[attribute]) {
    return;
  }
  payload[embeddedTypeKey] = payload[embeddedTypeKey] || [];
  var embeddedType = store.modelFor(relationship.type.typeKey);
  for (var key in partial) {
    if (partial.hasOwnProperty(key) &amp;&amp; key.camelize() === attr) {
      updatePayloadWithEmbedded.call(serializer, store, embeddedType, payload, partial[key]);
    }
  }
  partial[expandedKey] = partial[attribute].id;
  // Need to move an embedded &#x60;belongsTo&#x60; object into a pluralized collection
  payload[embeddedTypeKey].push(partial[attribute]);
  // Need a reference to the parent so relationship works between both &#x60;belongsTo&#x60; records
  partial[attribute][relationship.parentType.typeKey + &#x27;_id&#x27;] = partial.id;
  delete partial[attribute];
}

}(Ember, DS));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
